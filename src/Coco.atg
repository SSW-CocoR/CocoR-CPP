/*-------------------------------------------------------------------------
Coco.ATG -- Attributed Grammar
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   Coco Coco.ATG -namespace Coco
-------------------------------------------------------------------------*/
$namespace=Coco

#include "Tab.h"
#include "DFA.h"
#include "ParserGen.h"
#define COCO_FRAME_PARSER

COMPILER Coco

	int id;
	int str;

	FILE* trace;		// other Coco objects referenced in this ATG
	Tab *tab;
	DFA *dfa;
	ParserGen *pgen;

	bool genScanner, ignoreGammarErrors;
	wchar_t* tokenString;  // used in declarations of literal tokens
	wchar_t* noString;     // used in declarations of literal tokens

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		tab = NULL;
		dfa = NULL;
		pgen = NULL;
		id  = 0;
		str = 1;
		tokenString = NULL;
		noString = coco_string_create(_SC("-none-"));
		ignoreGammarErrors = false;
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }
/*-------------------------------------------------------------------------*/

CHARACTERS
	letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
	digit     = "0123456789".
	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.
	stringCh  = ANY - '"' - '\\' - cr - lf.
	charCh    = ANY - '\'' - '\\' - cr - lf.
	printable =  '\u0020' .. '\u007e'.
	hex       = "0123456789abcdef".

TOKENS
	ident     = letter { letter | digit }.
	number    = digit { digit }.
	string    = '"' { stringCh | '\\' printable } '"'.
	badString = '"' { stringCh | '\\' printable } (cr | lf).
	char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
	ddtSym    = '$' { digit | letter }.  (. tab->SetDDT(la->val); .)
	optionSym = '$' letter { letter } '='
	            { digit | letter
	            | '-' | '.' | ':'
	            }.                       (. tab->SetOption(la->val); .)


COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. Symbol *sym; Graph *g, *g1, *g2; wchar_t* gramName = NULL; CharSet *s; .)
=
                                (. int beg = la->pos; int line = la->line; .)
  { // this section can be used
    // for #include statements
    ANY
  }                             (. if (la->pos != beg) {
                                     pgen->usingPos = new Position(beg, t->pos + coco_string_length(t->val), 0, line);
                                   }
                                .)
                                
  "COMPILER"                    (. genScanner = true; 
                                   tab->ignored = new CharSet(); .) 
  ident                         (. gramName = coco_string_create(t->val);
                                   beg = la->pos;
                                   line = la->line;
                                .)
  { ANY }                       (. tab->semDeclPos = new Position(beg, la->pos, 0, line); .)
  [ "IGNORECASE"                (. dfa->ignoreCase = true; .) ]   /* pdt */
  [ "TERMINALS" { ident 	(. sym = tab->FindSym(t->val);
                                    if (sym != NULL) SemErr(_SC("name declared twice"));
                                    else {
                                     sym = tab->NewSym(Node::t, t->val, t->line, t->col);
                                     sym->tokenKind = Symbol::fixedToken;
				}.)
	} ] /*from cocoxml*/
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<Node::t> }]
  [ "PRAGMAS" { TokenDecl<Node::pr> }]
  { "COMMENTS"                  (. bool nested = false; .)
    "FROM" TokenExpr<g1> 
    "TO" TokenExpr<g2>
    [ "NESTED"                  (. nested = true; .)
    ]                           (. dfa->NewComment(g1->l, g2->l, nested); delete g1; delete g2; .)
  }
  { "IGNORE" Set<s>         (. tab->ignored->Or(s); delete s; .)
  }

  SYNC 
  "PRODUCTIONS"                 (. if (genScanner) dfa->MakeDeterministic();
                                   tab->DeleteNodes();
                                 .)
  { ident                       (. sym = tab->FindSym(t->val);
                                   bool undef = (sym == NULL);
                                   if (undef) sym = tab->NewSym(Node::nt, t->val, t->line, t->col);
                                   else {
                                     if (sym->typ == Node::nt) {
                                       if (sym->graph != NULL) SemErr(_SC("name declared twice"));
                                   	 } else SemErr(_SC("this symbol kind not allowed on left side of production"));
                                   	 sym->line = t->line;
                                   }
                                   bool noAttrs = (sym->attrPos == NULL);
                                   sym->attrPos = NULL;
                                 .)
    [ AttrDecl<sym> ]           (. if (!undef)
                                     if (noAttrs != (sym->attrPos == NULL))
                                       SemErr(_SC("attribute mismatch between declaration and use of this symbol"));
                                 .)
    [ SemText<.sym->semPos.> ] WEAK
    '='
    Expression<g>               (. sym->graph = g->l;
                                   tab->Finish(g);
                                   delete g;
                                 .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (!coco_string_equal(gramName, t->val))
                                     SemErr(_SC("name does not match grammar name"));
                                   tab->gramSy = tab->FindSym(gramName);
                                   coco_string_delete(gramName);
                                   if (tab->gramSy == NULL)
                                     SemErr(_SC("missing production for grammar name"));
                                   else {
                                     sym = tab->gramSy;
                                     if (sym->attrPos != NULL)
                                       SemErr(_SC("grammar symbol must not have attributes"));
                                   }
                                   tab->noSym = tab->NewSym(Node::t, _SC("???"), 0, 0); // noSym gets highest number
                                   tab->SetupAnys();
                                   tab->RenumberPragmas();
                                   if (tab->ddt[2]) tab->PrintNodes();
                                   if (errors->count == 0) {
                                     wprintf(_SC("checking\n"));
                                     tab->CompSymbolSets();
                                     if (tab->ddt[7]) tab->XRef();
                                     bool doGenCode = false;
                                     if(ignoreGammarErrors) {
                                       doGenCode = true;
                                       tab->GrammarCheckAll();
                                     }
                                     else doGenCode = tab->GrammarOk();
				     if(tab->genRREBNF && doGenCode) {
					pgen->WriteRREBNF();
				     }
                                     if (doGenCode) {
                                       wprintf(_SC("parser"));
                                       pgen->WriteParser();
                                       if (genScanner) {
                                         wprintf(_SC(" + scanner"));
                                         dfa->WriteScanner();
                                         if (tab->ddt[0]) dfa->PrintStates();
                                       }
                                       wprintf(_SC(" generated\n"));
                                       if (tab->ddt[8]) pgen->WriteStatistics();
                                     }
                                   }
                                   if (tab->ddt[6]) tab->PrintSymbolTable();
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. CharSet *s; .)
=
  ident                         (. wchar_t *name = coco_string_create(t->val);
                                   CharClass *c = tab->FindCharClass(name);
                                   if (c != NULL) SemErr(_SC("name declared twice"));
                                 .)
  '=' Set<s>                    (. if (s->Elements() == 0) SemErr(_SC("character set must not be empty"));
                                   tab->NewCharClass(name, s);
                                   coco_string_delete(name);
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<CharSet* &s>               (. CharSet *s2; .)
=
  SimSet<s>
  { '+' SimSet<s2>              (. s->Or(s2); delete s2; .)
  | '-' SimSet<s2>              (. s->Subtract(s2); delete s2; .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<CharSet* &s>             (. int n1, n2; .)
=                               (. s = new CharSet(); .)
( ident                         (. CharClass *c = tab->FindCharClass(t->val);
                                   if (c == NULL) SemErr(_SC("undefined name")); else s->Or(c->set);
                                .)
| string                        (.
				   wchar_t *subName2 = coco_string_create(t->val, 1, coco_string_length(t->val)-2);
				   wchar_t *name = tab->Unescape(subName2);
				   coco_string_delete(subName2);
				   wchar_t ch;
				   int len = coco_string_length(name);
				   for(int i=0; i < len; i++) {
				     ch = name[i];
				     if (dfa->ignoreCase) {
				       if ((_SC('A') <= ch) && (ch <= _SC('Z'))) ch = ch - (_SC('A') - _SC('a')); // ch.ToLower()
				     }
				     s->Set(ch);
				   }
				   coco_string_delete(name);
				.)
| Char<n1>                      (. s->Set(n1); .)
  [ ".." Char<n2>               (. for (int i = n1; i <= n2; i++) s->Set(i); .)
  ]
| "ANY"                         (. delete s; s = new CharSet(); s->Fill(); .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<int &n>
=
  char                          (. n = 0;
				   wchar_t* subName = coco_string_create(t->val, 1, coco_string_length(t->val)-2);
				   wchar_t* name = tab->Unescape(subName);
				   coco_string_delete(subName);

				   // "<= 1" instead of "== 1" to allow the escape sequence '\0' in c++
				   if (coco_string_length(name) <= 1) n = name[0];
				   else SemErr(_SC("unacceptable character value"));
				   coco_string_delete(name);
				   if (dfa->ignoreCase && (((wchar_t) n) >= 'A') && (((wchar_t) n) <= 'Z')) n += 32;
                                 .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<int typ>              (. wchar_t* name = NULL; int kind; Symbol *sym; Graph *g; .)
=
  Sym<name, kind>               (. sym = tab->FindSym(name);
                                   if (sym != NULL) SemErr(_SC("name declared twice"));
                                   else {
                                     sym = tab->NewSym(typ, name, t->line, t->col);
                                     sym->tokenKind = Symbol::fixedToken;
                                   }
                                   coco_string_delete(name);
                                   coco_string_delete(tokenString);
                                 .)
  SYNC
  ( '=' TokenExpr<g> '.'        (. if (kind == str) SemErr(_SC("a literal must not be declared with a structure"));
                                   tab->Finish(g);
                                   if (tokenString == NULL || coco_string_equal(tokenString, noString))
                                     dfa->ConvertToStates(g->l, sym);
                                   else { // TokenExpr is a single string
                                     if (tab->literals[tokenString] != NULL)
                                       SemErr(_SC("token string declared twice"));
                                     tab->literals.Set(tokenString, sym);
                                     dfa->MatchLiteral(tokenString, sym);
                                   }
                                   delete g;
                                 .)
  |                             (. if (kind == id) genScanner = false;
                                   else dfa->MatchLiteral(sym->name, sym);
                                 .)
  )
  [ SemText<.sym->semPos.>      (. if (typ == Node::t) errors->Warning(_SC("Warning semantic action on token declarations require a custom Scanner")); .) //(. if (typ != Node::pr) SemErr(_SC("semantic action not allowed here")); .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<Symbol *sym>
=
  '<'                           (. int beg = la->pos; int col = la->col; int line = la->line; .)
  { ANY
  | badString                   (. SemErr(_SC("bad string in attributes")); .)
  }
  '>'                           (. if (t->pos > beg)
                                     sym->attrPos = new Position(beg, t->pos, col, line); .)
| "<."                          (. int beg = la->pos; int col = la->col; int line = la->line; .)
  { ANY
  | badString                   (. SemErr(_SC("bad string in attributes")); .)
  }
  ".>"                          (. if (t->pos > beg)
                                     sym->attrPos = new Position(beg, t->pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

Expression<Graph* &g>           (. Graph *g2; .)
= 
  Term<g>                       (. bool first = true; .)
  {                             WEAK
    '|'
    Term<g2>                    (. if (first) { tab->MakeFirstAlt(g); first = false; }
                                   tab->MakeAlternative(g, g2); delete g2;
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<Graph* &g>               (. Graph *g2; Node *rslv = NULL; g = NULL; .)
=
( [                           (. rslv = tab->NewNode(Node::rslv, (Symbol*)NULL, la->line, la->col); .)
    Resolver<.rslv->pos.>       (. g = new Graph(rslv); .)
  ]
  Factor<g2>                  (. if (rslv != NULL) {tab->MakeSequence(g, g2); delete g2;}
                                 else g = g2; .)
  { Factor<g2>                (. tab->MakeSequence(g, g2); delete g2; .)
  }
|                             (. g = new Graph(tab->NewNode(Node::eps, (Symbol*)NULL, 0, 0)); .)
)                             (. if (g == NULL) // invalid start of Term
                                 g = new Graph(tab->NewNode(Node::eps, (Symbol*)NULL, 0, 0)); .)
.

/*------------------------------------------------------------------------------------*/

Factor<Graph* &g>             (. wchar_t* name = NULL; int kind; Position *pos; bool weak = false; 
                                   g = NULL;
                                 .)
=
( [ "WEAK"                      (. weak = true; .)
  ]
  Sym<name, kind>             (. Symbol *sym = tab->FindSym(name);
                                   if (sym == NULL && kind == str)
                                     sym = (Symbol*)tab->literals[name];
                                   bool undef = (sym == NULL);
                                   if (undef) {
                                     if (kind == id)
                                       sym = tab->NewSym(Node::nt, name, 0, 0);  // forward nt
                                     else if (genScanner) { 
                                       sym = tab->NewSym(Node::t, name, t->line, t->col);
                                       dfa->MatchLiteral(sym->name, sym);
                                     } else {  // undefined string in production
                                       SemErr(_SC("undefined string in production"));
                                       sym = tab->eofSy;  // dummy
                                     }
                                   }
                                   coco_string_delete(name);
                                   int typ = sym->typ;
                                   if (typ != Node::t && typ != Node::nt)
                                     SemErr(_SC("this symbol kind is not allowed in a production"));
                                   if (weak) {
                                     if (typ == Node::t) typ = Node::wt;
                                     else SemErr(_SC("only terminals may be weak"));
                                   }
                                   Node *p = tab->NewNode(typ, sym, t->line, t->col);
                                   g = new Graph(p);
                                 .)
  [ Attribs<p>                  (. if (kind != id) SemErr(_SC("a literal must not have attributes")); .)
  ]                             (. if (undef)
                                     sym->attrPos = p->pos;  // dummy
                                   else if ((p->pos == NULL) != (sym->attrPos == NULL))
                                     SemErr(_SC("attribute mismatch between declaration and use of this symbol"));
                                 .)
| '(' Expression<g> ')'
| '[' Expression<g> ']'     (. tab->MakeOption(g); .)
| '{' Expression<g> '}'     (. tab->MakeIteration(g); .)
| SemText<pos>              (. Node *p = tab->NewNode(Node::sem, (Symbol*)NULL, 0, 0);
                                   p->pos = pos;
                                   g = new Graph(p);
                                 .)
| "ANY"                         (. Node *p = tab->NewNode(Node::any, (Symbol*)NULL, 0, 0);  // p.set is set in tab->SetupAnys
                                   g = new Graph(p);
                                 .)
| "SYNC"                        (. Node *p = tab->NewNode(Node::sync, (Symbol*)NULL, 0, 0);
                                   g = new Graph(p);
                                 .)
)                               (. if (g == NULL) // invalid start of Factor
                                     g = new Graph(tab->NewNode(Node::eps, (Symbol*)NULL, 0, 0));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Resolver<Position* &pos>   
=
  "IF" "("                       (. int beg = la->pos; int col = la->col; int line = la->line; .)
  Condition                      (. pos = new Position(beg, t->pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<Graph* &g>            (. Graph *g2; .)
=
  TokenTerm<g>                  (. bool first = true; .)
  {                             WEAK
    '|'
    TokenTerm<g2>               (. if (first) { tab->MakeFirstAlt(g); first = false; }
                                   tab->MakeAlternative(g, g2); delete g2;
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<Graph* &g>        (. Graph *g2; .)
=
  TokenFactor<g>
  { TokenFactor<g2>         (. tab->MakeSequence(g, g2); delete g2; .)
  }
  [ "CONTEXT"
    '(' TokenExpr<g2>       (. tab->SetContextTrans(g2->l); dfa->hasCtxMoves = true;
                                   tab->MakeSequence(g, g2); delete g2; .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<Graph* &g>        (. wchar_t* name = NULL; int kind; .)
=
                              (. g = NULL; .)
( Sym<name, kind>             (. if (kind == id) {
                                     CharClass *c = tab->FindCharClass(name);
                                     if (c == NULL) {
                                       SemErr(_SC("undefined name"));
                                       c = tab->NewCharClass(name, new CharSet());
                                     }
                                     Node *p = tab->NewNode(Node::clas, (Symbol*)NULL, 0, 0); p->val = c->n;
                                     g = new Graph(p);
                                     coco_string_delete(tokenString); tokenString = coco_string_create(noString);
                                   } else { // str
                                     g = tab->StrToGraph(name);
                                     if (tokenString == NULL) tokenString = coco_string_create(name);
                                     else {
                                       coco_string_delete(tokenString);
                                       tokenString = coco_string_create(noString);
                                     }
                                   }
                                   coco_string_delete(name);
                                 .)
| '(' TokenExpr<g> ')'
| '[' TokenExpr<g> ']'      (. tab->MakeOption(g); coco_string_delete(tokenString); tokenString = coco_string_create(noString); .)
| '{' TokenExpr<g> '}'      (. tab->MakeIteration(g); coco_string_delete(tokenString); tokenString = coco_string_create(noString); .)
)                               (. if (g == NULL) // invalid start of TokenFactor
                                     g = new Graph(tab->NewNode(Node::eps, (Symbol*)NULL, 0, 0)); .)
.

/*------------------------------------------------------------------------------------*/

Sym<wchar_t* &name, int &kind>
=                               (. name = coco_string_create(_SC("???")); kind = id; .)
( ident                         (. kind = id; coco_string_delete(name); name = coco_string_create(t->val); .)
| (string                       (. coco_string_delete(name); name = coco_string_create(t->val); .)
  | char                        (.
				   wchar_t *subName = coco_string_create(t->val, 1, coco_string_length(t->val)-2);
				   coco_string_delete(name);
				   name = coco_string_create_append(_SC("\""), subName);
				   coco_string_delete(subName);
				   coco_string_merge(name, _SC("\""));
			    .)
  )                             (. kind = str;
                                   if (dfa->ignoreCase) {
					 wchar_t *oldName = name;
					 name = coco_string_create_lower(name);
					 coco_string_delete(oldName);
				   }
                                   if (coco_string_indexof(name, ' ') >= 0)
                                     SemErr(_SC("literal tokens must not contain blanks")); .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<Node *p>
=
  '<'                           (. int beg = la->pos; int col = la->col; int line = la->line; .)
  { ANY 
  | badString                   (. SemErr(_SC("bad string in attributes")); .)
  }
  '>'                           (. if (t->pos > beg) p->pos = new Position(beg, t->pos, col, line); .)
| "<."                          (. int beg = la->pos; int col = la->col; int line = la->line; .)
  { ANY 
  | badString                   (. SemErr(_SC("bad string in attributes")); .)
  }
  ".>"                          (. if (t->pos > beg) p->pos = new Position(beg, t->pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

SemText<Position* &pos>
=
  "(."                          (. int beg = la->pos; int col = la->col; int line = t->line; .)
  { ANY
  | badString                   (. SemErr(_SC("bad string in semantic action")); .)
  | "(."                        (. SemErr(_SC("missing end of previous semantic action")); .)
  }
  ".)"                          (. pos = new Position(beg, t->pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/
  
END Coco.
